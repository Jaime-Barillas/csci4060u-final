#include "lib.h"
#include "matrix.h"
#include "Vec3.h"
#include <expected>
#include <filesystem>
#include <SDL3/SDL.h>
#include <SDL3/SDL_gpu.h>
#include <SDL3/SDL_init.h>
#include <SDL3/SDL_iostream.h>
#include <SDL3/SDL_video.h>

namespace libcommon {
  using libcommon_return_t = std::expected<SDLCtx*, SDLError>;

  libcommon_return_t _init_sdl(const char *exe_dir, uint32_t particle_count) {
    // NOTE: Hard-coded workgroup size total of 64.
    if (particle_count == 0 || particle_count % 64 != 0) {
      return std::unexpected((SDLError){
        .ctx = nullptr,
        .type = SDLErrorType::BadParticleCount,
      });
    }

    if (!SDL_Init(SDL_INIT_VIDEO)) {
      return std::unexpected((SDLError){
        .ctx = nullptr,
        .type = SDLErrorType::Initialization,
      });
    }

    return new SDLCtx{
      .exe_dir = exe_dir,
      .particle_count = particle_count,
    };
  }

  SDLError _quit_sdl(SDLError error) {
    if (error.type > SDLErrorType::Initialization) {
      SDL_Quit();
      delete error.ctx;
      error.ctx = nullptr;
    }

    return error;
  }

  libcommon_return_t _create_window(SDLCtx *ctx) {
    SDL_DisplayID display;
    SDL_Rect bounds;

    display = SDL_GetPrimaryDisplay();
    if (display == 0) {
      bounds.w = 720;
      bounds.h = 720;
    } else {
      SDL_GetDisplayBounds(display, &bounds);
    }

    bounds.w = (bounds.w * 2) / 3;
    bounds.h = (bounds.h * 2) / 3;
    float aspect_ratio = static_cast<float>(bounds.w) / bounds.h;
    ctx->window_width = bounds.w;
    ctx->window_height = bounds.h;
    // NOTE: near & far get extended an additional amount (from [1, 3]) to
    //       account for the rotation used in main.cpp. The extent of the
    //       x-axis (-1 to 1) is larger than the extent of the z-axis (0 to
    //       1) in NDC. When rotating, it could cause vertices to fall outside
    //       the clipping range.
    ctx->projection = matrix::perspective(100, aspect_ratio, 0.5, 3.5);

    ctx->window = SDL_CreateWindow("fluid-sim-sph", bounds.w, bounds.h, 0);
    if (!ctx->window) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::WindowCreation,
      });
    }

    return ctx;
  }

  SDLError _destroy_window(SDLError error) {
    if (error.type > SDLErrorType::WindowCreation) {
      SDL_DestroyWindow(error.ctx->window);
    }

    return error;
  }

  libcommon_return_t _create_gpu_device_and_claim_window(SDLCtx *ctx) {
    ctx->device = SDL_CreateGPUDevice(SDL_GPU_SHADERFORMAT_SPIRV, true, nullptr);
    if (!ctx->device) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::GpuDeviceCreation,
      });
    }

    if (!SDL_ClaimWindowForGPUDevice(ctx->device, ctx->window)) {
      SDL_DestroyGPUDevice(ctx->device);
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ClaimingWindow,
      });
    }

    return ctx;
  }

  SDLError _release_window_and_destroy_gpu_device(SDLError error) {
    if (error.type > SDLErrorType::ClaimingWindow) {
      SDL_ReleaseWindowFromGPUDevice(error.ctx->device, error.ctx->window);
    }

    if (error.type > SDLErrorType::GpuDeviceCreation) {
      SDL_DestroyGPUDevice(error.ctx->device);
    }

    return error;
  }

  libcommon_return_t _setup_gpu_buffers(SDLCtx *ctx) {
    uint32_t data_size = 0;

    data_size = static_cast<uint32_t>(sizeof(Vec3) * ctx->particle_count);

    SDL_GPUTransferBufferCreateInfo ti = {
      .usage = SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD,
      .size = data_size,
      .props = 0,
    };

    ctx->bufs.point_sprites.t = SDL_CreateGPUTransferBuffer(ctx->device, &ti);
    if (!ctx->bufs.point_sprites.t) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::TransferBufferAlloc,
      });
    }

    SDL_GPUBufferCreateInfo bi = {
      .usage = SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ,
      .size = data_size,
      .props = 0,
    };

    ctx->bufs.point_sprites.b = SDL_CreateGPUBuffer(ctx->device, &bi);
    if (!ctx->bufs.point_sprites.b) {
      SDL_ReleaseGPUTransferBuffer(ctx->device, ctx->bufs.point_sprites.t);
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::GpuBufferAlloc,
      });
    }

    // The following holds the quads generated by the compute shader to be
    // used as vertices in a subsequent render pass.
    bi.usage = SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE | SDL_GPU_BUFFERUSAGE_VERTEX;
    bi.size = data_size * 6;
    ctx->bufs.pass1.verts = SDL_CreateGPUBuffer(ctx->device, &bi);
    if (!ctx->bufs.pass1.verts) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::GpuBufferAlloc,
      });
    }

    bi.usage = SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE | SDL_GPU_BUFFERUSAGE_VERTEX;
    bi.size = static_cast<uint32_t>(sizeof(float) * 2 * ctx->particle_count) * 6;
    ctx->bufs.pass1.texcoords = SDL_CreateGPUBuffer(ctx->device, &bi);
    if (!ctx->bufs.pass1.texcoords) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::GpuBufferAlloc,
      });
    }

    return ctx;
  }

  SDLError _teardown_buffers(SDLError error) {
    if (error.type > SDLErrorType::TransferBufferAlloc ||
        error.type > SDLErrorType::GpuBufferAlloc) {
      if (error.ctx->bufs.pass1.texcoords) {
        SDL_ReleaseGPUBuffer(error.ctx->device, error.ctx->bufs.pass1.texcoords);
      }
      if (error.ctx->bufs.pass1.verts) {
        SDL_ReleaseGPUBuffer(error.ctx->device, error.ctx->bufs.pass1.verts);
      }
      if (error.ctx->bufs.point_sprites.b) {
        SDL_ReleaseGPUBuffer(error.ctx->device, error.ctx->bufs.point_sprites.b);
      }
      if (error.ctx->bufs.point_sprites.t) {
        SDL_ReleaseGPUTransferBuffer(error.ctx->device, error.ctx->bufs.point_sprites.t);
      }
    }

    return error;
  }

  libcommon_return_t _create_compute_pipelines(SDLCtx *ctx) {
    std::filesystem::path exe_dir(ctx->exe_dir);
    std::filesystem::path shader_path = exe_dir / "shaders" / "gen-point-sprites.spv";

    size_t code_size = 0;
    void *code = SDL_LoadFile(shader_path.c_str(), &code_size);
    if (!code) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ShaderNotFound,
      });
    }

    SDL_GPUComputePipelineCreateInfo cpi = {
      .code_size = code_size,
      .code = static_cast<uint8_t*>(code),
      .entrypoint = "main",
      .format = SDL_GPU_SHADERFORMAT_SPIRV,
      .num_samplers = 0,
      .num_readonly_storage_textures = 0,
      .num_readonly_storage_buffers = 1,
      .num_readwrite_storage_textures = 0,
      .num_readwrite_storage_buffers = 2,
      .num_uniform_buffers = 1,
      .threadcount_x = 64,
      .threadcount_y = 1,
      .threadcount_z = 1,
      .props = 0,
    };

    ctx->pipelines.gen_point_sprites = SDL_CreateGPUComputePipeline(ctx->device, &cpi);
    SDL_free(code);
    if (!ctx->pipelines.gen_point_sprites) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ComputePipelineCreation,
      });
    }

    return ctx;
  }

  SDLError _destroy_compute_pipelines(SDLError error) {
    if (error.type > SDLErrorType::ComputePipelineCreation) {
      SDL_ReleaseGPUComputePipeline(error.ctx->device, error.ctx->pipelines.gen_point_sprites);
    }

    return error;
  }

  libcommon_return_t _create_graphics_pipelines(SDLCtx *ctx) {
    std::filesystem::path exe_dir(ctx->exe_dir);
    std::filesystem::path shader_path = exe_dir / "shaders" / "vertex.spv";

    size_t code_size = 0;
    void *code = SDL_LoadFile(shader_path.c_str(), &code_size);
    if (!code) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ShaderNotFound,
      });
    }

    SDL_GPUShaderCreateInfo sci = {
      .code_size = code_size,
      .code = static_cast<uint8_t*>(code),
      .entrypoint = "main",
      .format = SDL_GPU_SHADERFORMAT_SPIRV,
      .stage = SDL_GPU_SHADERSTAGE_VERTEX,
      .num_samplers = 0,
      .num_storage_textures = 0,
      .num_storage_buffers = 0,
      .num_uniform_buffers = 1,
      .props = 0,
    };

    ctx->shaders.pass1_vertex = SDL_CreateGPUShader(ctx->device, &sci);
    SDL_free(code);
    if (!ctx->shaders.pass1_vertex) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ShaderCreation,
      });
    }

    shader_path = exe_dir / "shaders" / "fragment.spv";
    code = SDL_LoadFile(shader_path.c_str(), &code_size);
    if (!code) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ShaderNotFound,
      });
    }

    sci.code_size = code_size;
    sci.code = static_cast<uint8_t*>(code);
    sci.stage = SDL_GPU_SHADERSTAGE_FRAGMENT;
    ctx->shaders.pass1_fragment = SDL_CreateGPUShader(ctx->device, &sci);
    SDL_free(code);
    if (!ctx->shaders.pass1_fragment) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::ShaderCreation,
      });
    }

    SDL_GPUVertexBufferDescription gpi_vbd[2] = {
      { // Vertex buffer.
        .slot = 0,
        .pitch = sizeof(float) * 4,
        .input_rate = SDL_GPU_VERTEXINPUTRATE_VERTEX,
        .instance_step_rate = 0,
      },
      { // Texture coordinates.
        .slot = 1,
        .pitch = sizeof(float) * 2,
        .input_rate = SDL_GPU_VERTEXINPUTRATE_VERTEX,
        .instance_step_rate = 0,
      },
    };

    SDL_GPUVertexAttribute gpi_va[2] = {
      { // Vertex buffer.
        .location = 0,
        .buffer_slot = 0,
        .format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3,
        .offset = 0,
      },
      { // Texture coordinates.
        .location = 1,
        .buffer_slot = 1,
        .format = SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2,
        .offset = 0,
      },
    };

    SDL_GPUColorTargetDescription gpi_ctd = {
      .format = SDL_GetGPUSwapchainTextureFormat(ctx->device, ctx->window)
    };

    SDL_GPUGraphicsPipelineCreateInfo gpi = {
      .vertex_shader = ctx->shaders.pass1_vertex,
      .fragment_shader = ctx->shaders.pass1_fragment,
      .vertex_input_state = {
        .vertex_buffer_descriptions = gpi_vbd,
        .num_vertex_buffers = 2,
        .vertex_attributes = gpi_va,
        .num_vertex_attributes = 2,
      },
      .primitive_type = SDL_GPU_PRIMITIVETYPE_TRIANGLELIST,
      .rasterizer_state = {
        .enable_depth_clip = true,
      },
      .depth_stencil_state = {
        .compare_op = SDL_GPU_COMPAREOP_LESS_OR_EQUAL,
        .enable_depth_test = true,
        .enable_depth_write = true,
      },
      .target_info = {
        .color_target_descriptions = &gpi_ctd,
        .num_color_targets = 1,
        .depth_stencil_format = SDL_GPU_TEXTUREFORMAT_D32_FLOAT,
        .has_depth_stencil_target = true,
      },
    };

    ctx->pipelines.pass1 = SDL_CreateGPUGraphicsPipeline(ctx->device, &gpi);
    if (!ctx->pipelines.pass1) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::GraphicsPipelineCreation,
      });
    }

    return ctx;
  }

  SDLError _destroy_graphics_pipelines(SDLError error) {
    if (error.type > SDLErrorType::GraphicsPipelineCreation) {
      SDL_ReleaseGPUGraphicsPipeline(error.ctx->device, error.ctx->pipelines.pass1);
    }

    if (error.type > SDLErrorType::ShaderCreation) {
      if (error.ctx->shaders.pass1_vertex) {
        SDL_ReleaseGPUShader(error.ctx->device, error.ctx->shaders.pass1_vertex);
      }
      if (error.ctx->shaders.pass1_fragment) {
        SDL_ReleaseGPUShader(error.ctx->device, error.ctx->shaders.pass1_fragment);
      }
    }

    return error;
  }

  libcommon_return_t _create_textures(SDLCtx *ctx) {
    SDL_GPUTextureCreateInfo tci = {
      .type = SDL_GPU_TEXTURETYPE_2D,
      .format = SDL_GPU_TEXTUREFORMAT_D32_FLOAT,
      .usage = SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,
      .width = ctx->window_width,
      .height = ctx->window_height,
      .layer_count_or_depth = 1,
      .num_levels = 1,
      .sample_count = SDL_GPU_SAMPLECOUNT_1,
      .props = 0,
    };

    ctx->textures.depth = SDL_CreateGPUTexture(ctx->device, &tci);
    if (!ctx->textures.depth) {
      return std::unexpected((SDLError){
        .ctx = ctx,
        .type = SDLErrorType::DepthTextureCreation,
      });
    }

    return ctx;
  }

  SDLError _destroy_textures(SDLError error) {
    if (error.type > SDLErrorType::DepthTextureCreation) {
      SDL_ReleaseGPUTexture(error.ctx->device, error.ctx->textures.depth);
    }

    return error;
  }

  SDLError _teardown_on_error(SDLError error) {
    _destroy_textures(error);
    _destroy_graphics_pipelines(error);
    _destroy_compute_pipelines(error);
    _teardown_buffers(error);
    _release_window_and_destroy_gpu_device(error);
    _destroy_window(error);
    _quit_sdl(error);

    return error;
  }

  libcommon_return_t initialize_and_setup(const char *exe_dir, uint32_t particle_count) {
    return _init_sdl(exe_dir, particle_count)
      .and_then(_create_window)
      .and_then(_create_gpu_device_and_claim_window)
      .and_then(_setup_gpu_buffers)
      .and_then(_create_compute_pipelines)
      .and_then(_create_graphics_pipelines)
      .and_then(_create_textures)
      .transform_error(_teardown_on_error);
  }

  void teardown(SDLCtx *ctx) {
    // Wrap the ctx in an SDLError to reuse the _teardown_on_error logic.
    SDLError err = { .ctx = ctx, .type = SDLErrorType::None };
    _teardown_on_error(err);
  }

  bool update(SDLCtx *ctx) {
    SDL_Event ev;
    while (SDL_PollEvent(&ev)) {
      switch (ev.type) {
        case SDL_EVENT_QUIT:
          return false;
          break;
      }
    }

    return true;
  }

  void draw(
    SDLCtx *ctx,
    bool (*copy_callback)(SDLCtx *ctx, SDL_GPUTransferBuffer *tbuf, const void *particles_obj),
    const void *particles_obj
  ) {

    SDL_GPUCommandBuffer *cmds;
    SDL_GPUTexture *swapchain_tex;

    cmds = SDL_AcquireGPUCommandBuffer(ctx->device);
    if (!SDL_WaitAndAcquireGPUSwapchainTexture(cmds, ctx->window, &swapchain_tex, nullptr, nullptr)) {
      SDL_CancelGPUCommandBuffer(cmds);
      return;
    }

    upload_particles: {
      bool copy_result = false;
      if (copy_callback) {
        copy_result = copy_callback(ctx, ctx->bufs.point_sprites.t, particles_obj);
      }
      if (!copy_result) {
        goto gen_point_sprites; // TODO: No gotos?
      }

      SDL_GPUTransferBufferLocation source = {
        .transfer_buffer = ctx->bufs.point_sprites.t,
        .offset = 0,
      };
      SDL_GPUBufferRegion dest = {
        .buffer = ctx->bufs.point_sprites.b,
        .offset = 0,
        .size = static_cast<uint32_t>(sizeof(Vec3) * ctx->particle_count),
      };
      SDL_GPUCopyPass *upload_particles_pass = SDL_BeginGPUCopyPass(cmds);
      SDL_UploadToGPUBuffer(upload_particles_pass, &source, &dest, true);
      SDL_EndGPUCopyPass(upload_particles_pass);
    }

    gen_point_sprites: {
      SDL_GPUStorageBufferReadWriteBinding compute_rw_bindings[2] = {
        { // Vertex buffer.
          .buffer = ctx->bufs.pass1.verts,
          .cycle = true,
        },
        { // Texture coordinates.
          .buffer = ctx->bufs.pass1.texcoords,
          .cycle = true,
        },
      };
      SDL_GPUComputePass *gen_point_sprites_pass = SDL_BeginGPUComputePass(
        cmds,
        nullptr, 0,
        compute_rw_bindings, 2
      );
      SDL_BindGPUComputePipeline(gen_point_sprites_pass, ctx->pipelines.gen_point_sprites);
      SDL_BindGPUComputeStorageBuffers(gen_point_sprites_pass, 0, &(ctx->bufs.point_sprites.b), 1);
      SDL_PushGPUComputeUniformData(cmds, 0, &(ctx->model_view), sizeof(matrix::Mat4));
      // NOTE: Hard-coded workgroup size of 64 in the x dimension.
      SDL_DispatchGPUCompute(gen_point_sprites_pass, ctx->particle_count / 64, 1, 1);
      SDL_EndGPUComputePass(gen_point_sprites_pass);
    }

    render_pass: {
      SDL_GPUColorTargetInfo cti = {
        .texture = swapchain_tex,
        .clear_color = { .r = 0.00, .g = 0.05, .b = 0.25 },
        .load_op = SDL_GPU_LOADOP_CLEAR,
        .store_op = SDL_GPU_STOREOP_STORE,
      };
      SDL_GPUDepthStencilTargetInfo dsti = {
        .texture = ctx->textures.depth,
        .clear_depth = 1000,
        .load_op = SDL_GPU_LOADOP_CLEAR,
        .store_op = SDL_GPU_STOREOP_STORE,
        .stencil_load_op = SDL_GPU_LOADOP_CLEAR,
        .stencil_store_op = SDL_GPU_STOREOP_DONT_CARE,
        .cycle = true,
      };
      SDL_GPUBufferBinding vertex_buffer_bindings[2] = {
        {
          .buffer = ctx->bufs.pass1.verts,
          .offset = 0,
        },
        {
          .buffer = ctx->bufs.pass1.texcoords,
          .offset = 0,
        },
      };
      uint32_t num_vertices = ctx->particle_count * 6;
      SDL_GPURenderPass *render_pass = SDL_BeginGPURenderPass(cmds, &cti, 1, &dsti);
      SDL_BindGPUGraphicsPipeline(render_pass, ctx->pipelines.pass1);
      SDL_BindGPUVertexBuffers(render_pass, 0, vertex_buffer_bindings, 2);
      SDL_PushGPUVertexUniformData(cmds, 0, &(ctx->projection), sizeof(matrix::Mat4));
      SDL_DrawGPUPrimitives(render_pass, num_vertices, 1, 0, 0);
      SDL_EndGPURenderPass(render_pass);
    }

    SDL_SubmitGPUCommandBuffer(cmds);
  }
}
